<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>MakeIo (duppy.Duppy.MakeIo)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">duppy</a> &#x00BB; <a href="../index.html">Duppy</a> &#x00BB; MakeIo</nav><header class="odoc-preamble"><h1>Module <code><span>Duppy.MakeIo</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#parameters">Parameters</a></li><li><a href="#signature">Signature</a></li></ul></nav><div class="odoc-content"><h2 id="parameters"><a href="#parameters" class="anchor"></a>Parameters</h2><div class="odoc-spec"><div class="spec parameter anchored" id="argument-1-Transport"><a href="#argument-1-Transport" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-1-Transport/index.html">Transport</a></span><span> : <a href="../module-type-Transport_t/index.html">Transport_t</a></span></code></div></div><h2 id="signature"><a href="#signature" class="anchor"></a>Signature</h2><div class="odoc-spec"><div class="spec type anchored" id="type-socket"><a href="#type-socket" class="anchor"></a><code><span><span class="keyword">type</span> socket</span><span> = <a href="argument-1-Transport/index.html#type-t">Transport.t</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-marker"><a href="#type-marker" class="anchor"></a><code><span><span class="keyword">type</span> marker</span><span> = </span></code><ol><li id="type-marker.Length" class="def variant constructor anchored"><a href="#type-marker.Length" class="anchor"></a><code><span>| </span><span><span class="constructor">Length</span> <span class="keyword">of</span> int</span></code></li><li id="type-marker.Split" class="def variant constructor anchored"><a href="#type-marker.Split" class="anchor"></a><code><span>| </span><span><span class="constructor">Split</span> <span class="keyword">of</span> string</span></code></li></ol></div><div class="spec-doc"><p>Type for markers. * * <code>Split s</code> recognizes all regexp allowed by the * <code>Pcre</code> module.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-bigarray"><a href="#type-bigarray" class="anchor"></a><code><span><span class="keyword">type</span> bigarray</span><span> =
  <span><span>(char, <span class="xref-unresolved">Stdlib</span>.Bigarray.int8_unsigned_elt, <span class="xref-unresolved">Stdlib</span>.Bigarray.c_layout)</span>
    <span class="xref-unresolved">Stdlib</span>.Bigarray.Array1.t</span></span></code></div><div class="spec-doc"><p>Type of <code>Bigarray</code> used here.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-failure"><a href="#type-failure" class="anchor"></a><code><span><span class="keyword">type</span> failure</span><span> = </span></code><ol><li id="type-failure.Io_error" class="def variant constructor anchored"><a href="#type-failure.Io_error" class="anchor"></a><code><span>| </span><span><span class="constructor">Io_error</span></span></code></li><li id="type-failure.Unix" class="def variant constructor anchored"><a href="#type-failure.Unix" class="anchor"></a><code><span>| </span><span><span class="constructor">Unix</span> <span class="keyword">of</span> <span class="xref-unresolved">Unix</span>.error * string * string</span></code></li><li id="type-failure.Unknown" class="def variant constructor anchored"><a href="#type-failure.Unknown" class="anchor"></a><code><span>| </span><span><span class="constructor">Unknown</span> <span class="keyword">of</span> exn</span></code></li><li id="type-failure.Timeout" class="def variant constructor anchored"><a href="#type-failure.Timeout" class="anchor"></a><code><span>| </span><span><span class="constructor">Timeout</span></span></code></li></ol></div><div class="spec-doc"><p>Different types of failure. * * <code>Io_error</code> is raised when reading or writing * returned 0. This usually means that the socket * was closed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read"><a href="#val-read" class="anchor"></a><code><span><span class="keyword">val</span> read : 
  <span>?recursive:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?init:string <span class="arrow">&#45;&gt;</span></span>
  <span>?on_error:<span>(<span><span>(string * <a href="#type-failure">failure</a>)</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?timeout:float <span class="arrow">&#45;&gt;</span></span>
  <span>priority:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../index.html#type-scheduler">scheduler</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-socket">socket</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-marker">marker</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span>(string * <span>string option</span>)</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Wrapper to perform a read on a socket and trigger a function when * a marker has been detected, or enough data has been read. * It reads recursively on a socket, splitting into strings seperated * by the marker (if any) and calls the given function on the list of strings. * * Can be used recursively or not, depending on the way you process strings. * Because of Unix's semantic, it is not possible to stop reading * at first marker, so there can be a remaining string. If not used * recursively, the second optional argument may contain a remaining * string. You should then initiate the next read with this value. * * The <code>on_error</code> function is used when reading failed on the socket. * Depending on your usage, it can be a hard failure, or simply a lost client. * The string passed to <code>on_error</code> contains data read before error * occured. * </p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">recursive</span> <p>recursively read and process, default: <code>true</code> * </p><p>@param init</p><p>initial string for reading, default: <code>&quot;&quot;</code> * </p><p>@param on_error</p><p>function used when read failed, default: <code>fun _ -&gt; ()</code> * </p><p>@param timeout</p><p>Terminate with <code>Timeout</code> failure if nothing has been read * after the given amout of time in seconds. More precisely, * the exception is raised when no character have been read * and the socket was not close while waiting. Default: wait * forever.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write"><a href="#val-write" class="anchor"></a><code><span><span class="keyword">val</span> write : 
  <span>?exec:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?on_error:<span>(<span><a href="#type-failure">failure</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?bigarray:<a href="#type-bigarray">bigarray</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?offset:int <span class="arrow">&#45;&gt;</span></span>
  <span>?length:int <span class="arrow">&#45;&gt;</span></span>
  <span>?string:<span class="xref-unresolved">Stdlib</span>.Bytes.t <span class="arrow">&#45;&gt;</span></span>
  <span>?timeout:float <span class="arrow">&#45;&gt;</span></span>
  <span>priority:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../index.html#type-scheduler">scheduler</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-socket">socket</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Similar to <code>read</code> but less complex. * <code>write ?exec ?on_error ?string ?bigarray ~priority scheduler socket</code> * write data from <code>string</code>, or from <code>bigarray</code> if no string is given, * to <code>socket</code>, and executes <code>exec</code> or <code>on_error</code> if errors occured. * * Caveat: on Win32, all file descriptors are expected to be in blocking * mode before being passed to this call due to limitations in the emulation * of the unix/posix API. See code comments for more details. * * </p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">exec</span> <p>function to execute after writing, default: <code>fun () -&gt; ()</code> * </p><p>@param on_error</p><p>function to execute when an error occured, default: <code>fun _ -&gt; ()</code> * </p><p>@param string</p><p>write data from this string * </p><p>@param bigarray</p><p>write data from this bigarray, if no <code>string</code> is given * </p><p>@param timeout</p><p>Terminate with <code>Timeout</code> failure if nothing has been written * after the given amout of time in seconds. More precisely, * the exception is raised when no character have been written * and the socket was not close while waiting. Default: wait * forever.</p></li></ul></div></div></div></body></html>